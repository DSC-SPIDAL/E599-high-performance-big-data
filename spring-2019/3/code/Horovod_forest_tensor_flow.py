# -*- coding: utf-8 -*-
"""Forest Tensor Flow .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dWTn9Rkg-v99FjkIms_6vg6elD-nKJ8m
"""

import numpy as np
import random
from sklearn.model_selection import train_test_split
import time 
from sklearn.datasets import make_classification
from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score

import pandas as pd

import tensorflow as tf
import numpy as np
import decisionTree
import random
from scipy import stats
import pandas as pd
import random
from sklearn.metrics import f1_score
import horovod.tensorflow as hvd

maxDepth = 5

start = time.time()
hvd.init()
rank = hvd.rank()
numTrees = hvd.size()

print('rank',rank)

def splitData(xTrain,yTrain,numTrees):
  listOfRandomIndexes = [random.sample(list(range(yTrain.size)),int((2/3)*yTrain.size)) for i in range(numTrees)]
  return listOfRandomIndexes


airlineData =  pd.read_csv("AirlineReduced")
	
airlineData = airlineData.loc[:	, ~airlineData.columns.isin(['DepTime',
														'ArrTime', 
														'CRSArrTime',
														'CRSDepTime',
														'ActualElapsedTime',
														'ArrTimeInMins',
														'ArrDelay'])]
	
X_train, X_test, y_train, y_test = train_test_split(airlineData.loc[:, ~airlineData.columns.isin(['IsDelayed'])],
airlineData['IsDelayed'], test_size=0.25, random_state=42)

xTrain, xTest, yTrain, yTest = np.array(X_train),np.array(X_test),np.array(y_train),np.array(y_test)

indices = splitData(xTrain,yTrain,numTrees)
currSess = tf.InteractiveSession()



indexBC = tf.get_variable(initializer=tf.constant(indices), dtype=tf.int32, name="IndexBC")



### broadcast only for 0 rank
indicesBroadCast = hvd.broadcast(indexBC, 0)



def tree_fit_predict(xTrain,yTrain,xTest,index):
  model = decisionTree.DecisionTree(maxDepth = maxDepth,verbose = True)
#   new = tf.gather(xTrain,index)
#   print(new)
# #   index = np.array(index)
# #   index = index.astype(int)
# #   print(index.dtype)
  result  =  model.fit(xTrain[index],yTrain[index]).predict(xTest)
  return tf.convert_to_tensor(result)




xTrainTensor = tf.placeholder(tf.float32)
yTrainTensor = tf.placeholder(tf.float32)
xTestTensor = tf.placeholder(tf.float32)
indexTensor = tf.placeholder(tf.int32)


inputTensor = [xTrainTensor,yTrainTensor,xTestTensor,indexTensor]
tree_fit_predict_tensor = tf.py_func(tree_fit_predict, inputTensor, tf.float32)


currSess.run(tf.global_variables_initializer())


indices = indicesBroadCast.eval()

result = tree_fit_predict(xTrain,yTrain,xTest,indices[rank])

allgatherOp = hvd.allgather(result)


#print("rank is : ",rank, "result  " , result.eval())
print("rank is : ",rank, "indices  " , indices[0][0])
#print(allgatherOp.eval())


AllPreds = allgatherOp.eval()
#print("juggled up : ", np.sum(AllPreds[rank*len(y_test):rank*len(y_test)+len(y_test)] != result.eval() ),"rank:  ",rank)
#print("rank : ",rank,"allpreds :" ,AllPreds)
if rank == 0:
	#print("yTest is ",yTest)
	
	
	AllPreds = AllPreds.reshape(-1,len(y_test)).T
	print("Shape is : ",AllPreds.shape)
	MajorityPreds = stats.mode(AllPreds,axis = 1)[0]
	
	accuracy = f1_score(yTest, MajorityPreds)

	print("accuracy is :", accuracy)
# def predFromForest(numTrees,rank):
  # AllPreds = []
  
  # eachTreePreds = tree_fit_predict_tensor.eval(feed_dict = {xTrainTensor:xTrain,
												# yTrainTensor:yTrain,
												# xTestTensor:xTest, ##remains same
												# indexTensor:indices[rank]})
 
  # return 

  


# yPreds = predFromForest(numTrees,rank)
# accuracy = f1_score(yTest, yPreds)


computation_time = time.time() -start


print('computation time', str(computation_time), 'rank', rank)

# print("Time elapsed: ", time.time()- start)